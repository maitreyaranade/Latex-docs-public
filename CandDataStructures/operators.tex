Operators are the foundation of any programming language. We can define operators as symbols that help us to perform specific mathematical and logical computations on operands. In other words, we can say that an operator operates the operands. 

Types of operators based on the operations they perform are as follows:
\begin{enumerate}
    \item Arithmetic Operators
    \item Increment/Decrement Operators
    \item Relational Operators
    \item Logical Operators
    \item Bitwise Operators
    \item Assignment Operators
    \item Misc Operators
\end{enumerate}

\subsection{Arithmetic Operators}
Arithmetic Operators are used to performing mathematical calculations. All the operators are binary operators which mean they require 2 operands to perform operation. There are 5 types of Arithmetic Operators. 
\begin{enumerate}
    \item + Addition
    \item - Subtraction
    \item * Multiplication
    \item / Division
    \item \% Modulus
\end{enumerate}

\subsection{Increment/Decrement Operators}
Both the operators are unary operators. Both of them require only one operand to perform operation.

\begin{itemize}
    \item lvalue(left value): is an object that has an identifiable location in memory (i.e. having an address) ex. a variable.
    \item rvalue(right value): is an object that has no identifiable location in memory (i.e. having an address) ex. a function.
    \item Pre increment/decrement operator means first increment/decrement then assign it to another variable.
    \item Post increment/decrement operator means first assign it to another variable and then increment/decrement.
\end{itemize}
    
\subsubsection{Increment Operator (++)}
\begin{itemize}
    \item Increment operator is used to increment the value of a variable by one. 
    \item a++ is equivalent to a = a+1;
    \item There are 2 types of Increment Operator:
    \begin{itemize}
        \item Pre-increment operator (++a)
        \item Post-increment operator (a++)
    \end{itemize}
    \item 'rvalue' cannot be used with increment operator.
\end{itemize}

\subsubsection{Decrement Operator (--)}
\begin{itemize}
    \item Decrement operator is used to decrement the value of a variable by one. 
    \item a-- is equivalent to a = a-1;
    \item There are 2 types of decrement Operator:
    \begin{itemize}
        \item Pre-decrement operator (--a)
        \item Post-decrement operator (a--)
    \end{itemize}
    \item 'rvalue' cannot be used with decrement operator.
\end{itemize}

\subsection{Relational Operators}

\begin{itemize}
    \item Relational operators are used to comparing two quantities or values. 
    \item All the relational operators are binary operators.
    \item All the relational operators will return either True or False.
\end{itemize}
\begin{enumerate}
    \item == Is equal to
    \item != Is not equal to
    \item >	Greater than
    \item <	Less than
    \item >= Greater than or equal to
    \item <= Less than or equal to
\end{enumerate}

\subsection{Logical Operators}        
C provides three logical operators when we test more than one condition to make decisions. 

\begin{enumerate}
    \item \&\&   And operator: It performs logical conjunction of two expressions. (if both expressions evaluate to True, result is True. If either expression evaluates to False, the result is False)
    \item ||  Or operator: It performs a logical disjunction on two expressions. (if either or both expressions evaluate to True, the result is True)
    \item !	  Not operator: It performs logical negation on an expression.
\end{enumerate}

\subsection{Bitwise Operators}
C provides a special operator for bit operation between two variables.

\begin{enumerate}
    \item <<	Binary Left Shift Operator
    \item >>	Binary Right Shift Operator
    \item \~	Binary Ones Complement Operator
    \item \&	Binary AND Operator
    \item \^	Binary XOR Operator
    \item |	    Binary OR Operator
\end{enumerate}

\subsection{Assignment operators}
Assignment operators applied to assign the result of an expression to a variable. 

\begin{enumerate}
    \item =     Assign
    \item +=	Increment then assign
    \item -=	Decrement then assign
    \item *=	Multiply then assign
    \item /=	Divide then assign
    \item \%=	Modulus then assign
    \item <<=     Bitwise shift left then assign
    \item >>=     Bitwise shift right then assign
    \item \&=	Bitwise AND then assign
    \item |=	Bitwise OR then assign
    \item \^=	Bitwise XOR then assign
\end{enumerate}


\subsection{Conditional operators}
C offers only one ternary (requires 3 operands) operator which is the conditional operator (?: in combination) to construct conditional expressions. Ex. result = (Expression1) ? Expression2 : Expression3 ;

\begin{enumerate}
    \item ? :	 Conditional Expression
\end{enumerate}

\subsection{Special operators}   
C supports some special operators
\begin{enumerate}
    \item sizeof()	 Returns the size of a memory location.
    \item \&	     Returns the address of a memory location.
    \item *	         Pointer to a variable.
\end{enumerate}

\subsubsection{Comma operator (,)} 
\begin{itemize}
    \item Comma operator can be used as a separator.\\ For example: int var1 = 0, var2 = 1;
    \item Comma operator can be used as a "operator".\\ For example: int var1 = (0, 1, 2);\\ Comma operator returns the rightmost operand in the expression and it simply evaluates the rest of the operands and finally reject them.
    \item Comma operator has the least precedence among all the operators available in C language.
\end{itemize}


\subsection{Token generation}
\begin{itemize}
    \item Lexical analysis is the first phase in the compilation process.
    \item Lexical analyzer (scanner) scans the whole source program and it finds the meaningful sequence of characters(lexemes) then it converts it into a token.
    \item Token: lexemes mapped into token-name and attribute-value.\\ Example: int -> <keyword, int>
    \item Lexical analyzer always matches the longest character sequence.
\end{itemize}


\subsection{Operator precedence \& associativity}
Operator precedence determines the grouping of terms in an expression and decides how an expression is evaluated. Certain operators have higher precedence than others. For example, the multiplication operator has a higher precedence than the addition operator.

\subsubsection{Operator Precedence}
Operator precedence is used to evaluate the order of operators evaluated in an expression. In C programming, every operator has a priority. When there is more than one operator in the given expression, the operator with higher precedence or priority is evaluated first and the operator with the least priority is evaluated later.

\subsubsection{Operator Associativity}
Operator associativity is used to evaluate the order of operators with equal precedence in an expression. In the C programming language, when an expression contains multiple operators with equal or same precedence, we use associativity to determine the order of evaluation of operators.

\clearpage
\begin{table}[H]
    \begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{Precedence} &
        \textbf{Operator} &
        \textbf{Operator Meaning} &
        \textbf{Associativity} \\ \hline
    1 &
        \begin{tabular}[c]{@{}c@{}}()\\ \([\,]\)\\ ->\\ .\end{tabular} &
        \begin{tabular}[c]{@{}c@{}}Function Call\\ array reference\\ Structure member access\\ Structure member access\end{tabular} &
        Left to Right \\ \hline
    2 &
        \begin{tabular}[c]{@{}c@{}}!\\ $\sim$\\ +\\ -\\ ++\\ - -\\ \&\\ *\\ sizeof(type)\end{tabular} &
        \begin{tabular}[c]{@{}c@{}}negation\\ 1's complement\\ Unary Plus\\ Unary minus\\ Increment operator\\ decrement operator\\ address of operator\\ pointer\\ returns size of a variable type conversion\end{tabular} &
        Right to Left \\ \hline
    3 &
        \begin{tabular}[c]{@{}c@{}}*\\ /\\ \%\end{tabular} &
        \begin{tabular}[c]{@{}c@{}}multiplication\\ division\\ remainder\end{tabular} &
        Left to Right \\ \hline
    4 &
        \begin{tabular}[c]{@{}c@{}}+\\ -\end{tabular} &
        \begin{tabular}[c]{@{}c@{}}addition\\ subtraction\end{tabular} &
        Left to Right \\ \hline
    5 &
        \begin{tabular}[c]{@{}c@{}}\textless{}\textless\\ \textgreater{}\textgreater{}\end{tabular} &
        \begin{tabular}[c]{@{}c@{}}left shift\\ right shift\end{tabular} &
        Left to Right \\ \hline
    6 &
        \begin{tabular}[c]{@{}c@{}}\textless\\ \textless{}=\\ \textgreater\\ \textgreater{}= \end{tabular} &
        \begin{tabular}[c]{@{}c@{}}less than\\ less than or equal to\\ greater than\\ greater than or equal to\end{tabular} &
        Left to Right \\ \hline
    7 &
        \begin{tabular}[c]{@{}c@{}}==\\ !=\end{tabular} &
        \begin{tabular}[c]{@{}c@{}}equal to\\ not equal to\end{tabular} &
        Left to Right \\ \hline
    8 &
        \& &
        bitwise AND &
        Left to Right \\ \hline
    9 &
        \textasciicircum{} &
        bitwise EXCLUSIVE OR &
        Left to Right \\ \hline
    10 &
        | &
        bitwise OR &
        Left to Right \\ \hline
    11 &
        \&\& &
        logical AND &
        Left to Right \\ \hline
    12 &
        || &
        logical OR &
        Left to Right \\ \hline
    13 &
        ?: &
        Conditional Operator &
        Left to Right \\ \hline
    14 &
        \begin{tabular}[c]{@{}c@{}}=\\ *=\\ /=\\ \%=\\ +=\\ -=\\ \&=\\ \textasciicircum{}=\\ |=\\ \textless{}\textless{}=\\ \textgreater{}\textgreater{}=\end{tabular} &
        \begin{tabular}[c]{@{}c@{}}assignment\\ assign multiplication\\ assign division\\ assign remainder\\ assign addition\\ assign subtraction\\ assign bitwise AND\\ assign bitwise XOR\\ assign bitwise OR\\ assign left shift\\ assign right shift\end{tabular} &
        Right to Left \\ \hline
    15 & ,
        &
        comma &
        Left to Right \\ \hline
    \end{tabular}
\end{table}